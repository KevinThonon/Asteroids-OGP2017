package asteroids.model;

import java.util.HashSet;
import java.util.List;
import java.util.Set;



public class World {
	
	public double width;
	public double height;
	
	/**Create a world with a width and height 
	 * expressed in kilometres (km).
	 * 
	 * @param width
	 * 		  The width of this world.
	 * @param height
	 * 		  The height of this world.
	 * @post  this.width = width
	 * @post  this.height = height
	 * 
	 */
	
	public World(double width, double height){
		this.width = width;
		this.height = height;
	}
	
	public double getWidth(){
		return width;
	}
	
	public double getHeigth(){
		return height;
	}
	public Set<Ship> getShips(){
		return ships;
	}
	
	private Set<Ship> ships = new HashSet<Ship>();
	
	public Set<Bullet> getBullets(){
		return bullets;
	}
	
	
	private Set<Bullet> bullets = new HashSet<Bullet>();
	
    public Set<Entity> getEntitys(){
		entitys.addAll(getBullets());
		entitys.addAll(getShips());
		return this.entitys;
	}
	
	private Set<Entity> entitys = new HashSet<Entity>();  
	
	
	private boolean canHaveAsShip(Ship ship1) {
		for (Ship ship2: getShips()){
			if (ship1.overlap(ship1, ship2))
				return false;}
		for (Bullet bullet: getBullets()){
			if (ship1.overlap(ship1,bullet))
			    return false;}
		if (ship1.getWorld() == this || ship1.getWorld() == null )  //intorduce getWorld() en setWorld en isValidWorld (definsief) in entity class
			return true;
		return false;
	}
	
	public void addShip(Ship ship) {
		if (!canHaveAsShip(ship)) throw new IllegalArgumentException("The world can't have this ship.");
		ships.add(ship);
		ship.setWorld(this);
	}
	
	public void removeShip(Ship ship) {
		if (ship.getWorld() != this) throw new IllegalArgumentException("This ship isn't in this world.");
		ships.remove(ship);
		ship.setWorld(null);
	}
	
	private boolean canHaveAsBullet(Bullet bullet1) {
		for (Bullet bullet2: getBullets()) {
			if (bullet1.overlap(bullet1,bullet2))
				return false;}
		for (Ship ship: getShips()) {
			if (bullet1.overlap(bullet1,ship))
				return false;}
		if (bullet1.getWorld() == this || bullet1.getWorld() == null )
			return true;
		return false;
	}
	
	public void addBullet(Bullet bullet) {
		if (!canHaveAsBullet(bullet)) throw new IllegalArgumentException("The world can't have this bullet.");
		bullets.add(bullet);
		bullet.setWorld (this);
	}
	
	public void removeBullet(Bullet bullet) {
		if (bullet.getWorld() != this) throw new IllegalArgumentException("This bullet isn't in this world");
		bullets.remove(bullet);
		bullet.setWorld(null);
	}
	
	
	
	public double getMinCollisionInWorld(){
		Set<Entity> entitystocontrol = getEntitys();
		double mintimetocollision = Double.POSITIVE_INFINITY; 
		for (Entity entity1: getEntitys()) {
			if (entity1.timeToBoundaryCollision() < mintimetocollision)
				mintimetocollision= entity1.timeToBoundaryCollision();
			entitystocontrol.remove(entity1);
			for (Entity entity2: entitystocontrol){
				double timetocollision = entity1.getTimeToCollision(entity1,entity2);
				if (timetocollision < mintimetocollision)
					mintimetocollision = timetocollision;
			}
		}
		return mintimetocollision;
	}
	
	public boolean isBulletClass(Entity entity){
    	if (entity instanceof Ship)
    		return false;
        return true;
    }
	
    public boolean isShipClass(Entity entity){
    	if (entity instanceof Ship)
    		return true;
    	return false;
    }
	
	public List<Entity> getCollisions(){
		List<Entity> collisions = null;
		Set<Entity> entitystocontrol = getEntitys();
		double mintimetocollision = Double.POSITIVE_INFINITY; 
		for (Entity entity1: getEntitys()) {
			if (entity1.timeToBoundaryCollision() < mintimetocollision){
				mintimetocollision= entity1.timeToBoundaryCollision();
				collisions.clear();
				collisions.add(entity1);
			}
			entitystocontrol.remove(entity1);
			for (Entity entity2: entitystocontrol){
				double timetocollision = entity1.getTimeToCollision(entity1,entity2);
				if (timetocollision < mintimetocollision){
					mintimetocollision = timetocollision;
					collisions.clear();
					collisions.add(entity1);
					collisions.add(entity2);
				}
			}
		}
		return collisions;
	}
	
	private boolean isValidTime(double time){
		if (time < 0)
			return false;
		if (time == Double.POSITIVE_INFINITY)
			return false;
		if (time == Double.NaN)
			return false;
		return true;
		
	}
	
	public void collisionBetweenBulletBullet(Bullet bullet1,Bullet bullet2){
		bullets.remove(bullet1);
		bullets.remove(bullet2);
	}
	
	public void collisionBetweenShipShip(Ship ship1, Ship ship2){
		double J = 2*(ship1.getMass())*(ship2.getMass())*ship1.dotProduct(ship1.deltaPosition(ship1, ship2),ship1.deltaSpeed(ship1, ship2))
				/(ship1.getDensity()*(ship1.getMass()*ship2.getMass()));
		double Jx = (J*ship1.deltaX(ship1, ship2))/(ship1.getDensity());
		double Jy = (J*ship1.deltaY(ship1, ship2))/(ship1.getDensity());
		ship1.setSpeed(new double[] {ship1.getSpeed()[0] + Jx/ship1.getMass(), ship1.getSpeed()[1] + Jy/ship1.getMass()});
		ship2.setSpeed(new double[] {ship2.getSpeed()[0] - Jx/ship2.getMass(), ship2.getSpeed()[1] - Jy/ship2.getMass()});
	}
	
	public void collisionBetweenShipBullet(Ship ship,Bullet bullet){
		if (ship == bullet.getSource()){
			//the bullet is reloaded on the ship, with its position equal to the centre of the ship.
		}
		else{
			bullets.remove(bullet);
			ships.remove(ship);
		}
	}
	
	
	public void collisionWithShipBoundry(Ship ship){
		if((ship.positionBoundaryCollision()[0] - width) < (ship.positionBoundaryCollision()[1] - height)){
			ship.setSpeed(new double[] {-ship.getSpeed()[0],ship.getSpeed()[1]});
		}
		else{
			ship.setSpeed(new double[] {ship.getSpeed()[0],-ship.getSpeed()[1]});
		}
	}
	
	
	public void collisionWithBulletBoundry(Bullet bullet){
		if (bullet.residualbounces == 0){
			bullets.remove(bullet);}
		else{
			if((bullet.positionBoundaryCollision()[0] - width) < (bullet.positionBoundaryCollision()[1] - height)){
				bullet.setSpeed(new double[] {-bullet.getSpeed()[0],bullet.getSpeed()[1]});
			}
			else{
				bullet.setSpeed(new double[] {bullet.getSpeed()[0],-bullet.getSpeed()[1]});
			}
			bullet.substractBounce();
		}
	}
	
    
	public void collisionWithEntity(){
		List<Entity> entities = getCollisions();
		if(entities.size()==1){
			if (isShipClass(entities.get(0))){
				collisionWithShipBoundry((Ship)entities.get(0));
			}
			else{
				collisionWithBulletBoundry((Bullet)entities.get(0));
			}
		}
		else{
			if (isShipClass(entities.get(0)) || isShipClass(entities.get(1))){
				if (isShipClass(entities.get(1)) && isShipClass(entities.get(0))){
					collisionBetweenShipShip((Ship)entities.get(0),(Ship)entities.get(1));
				}
				else{
					if (isBulletClass(entities.get(0))){
						collisionBetweenShipBullet((Ship)entities.get(1),(Bullet)entities.get(0));
					}
					else{
						collisionBetweenShipBullet((Ship)entities.get(0),(Bullet)entities.get(1));
					}
				}
			}
			else{
				collisionBetweenBulletBullet((Bullet)entities.get(0),(Bullet)entities.get(1));
			}
		}
	}
			
	public void evolve(double time){
		if (!(isValidTime(time))) throw new IllegalArgumentException("This given certain time isn't valid");
		double T = time;
		double ready = 1;
		while (ready != 0){
			if ( getMinCollisionInWorld()<T){
				collisionWithEntity();
				T = T - getMinCollisionInWorld();
			}
			else{
				ready = 0; 
			}
		}
		for (Entity entity: getEntitys()){
			entity.move(T);
		}
	}
	
	public void destroyWorld(){
		Set<Entity> entities = getEntitys();
		for (Entity entity: entities){
			entity.setWorld(null);
			}
		entitys.clear();
		bullets.clear();
		ships.clear();
		}
	
	public boolean isDestoyedWorld(){
		if (bullets.size()==0 && ships.size()==0)
			return true;
		return false;
		
	}
	
}


