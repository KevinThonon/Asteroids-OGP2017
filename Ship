package asteroids.facade;

public class Ship {
	public Ship(double xPosition, double yPosition, double xSpeed, double ySpeed, 
			double orientation, double radius) throws IllegalArgumentException {
		this.setPosition(new double[] {xPosition,yPosition});
		this.setSpeed(new double[] {xSpeed,ySpeed});
		this.setOrientation(orientation);
		this.setRadius(radius);
	}
	
	private double xPosition;
	private double yPosition;
	private double xSpeed;
	private double ySpeed;
	private double orientation;
	private double radius;
	
	public double[] getPosition(){
		return this.position;
	}
	
	public void setPosition(double[] position) throws IllegalArgumentException{
		if ((xPosition < Double.NEGATIVE_INFINITY) || (xPosition > Double.POSITIVE_INFINITY) 
				|| (yPosition < Double.NEGATIVE_INFINITY) || (yPosition > Double.POSITIVE_INFINITY)) 
			throw new IllegalArgumentException();
		if (position.length != 2) throw new IllegalArgumentException();
		this.position = position;
	}
	
	private double[] position = new double[2];
	
	private double[] speed = new double[2];
	
	public double[] getSpeed(){
		return this.speed;
	}
	
	private double reducer;
	
	public void setSpeed (double[] speed) {
		if (Math.sqrt(Math.pow( xSpeed , 2) + Math.pow(ySpeed, 2) )  < MaxSpeed)
			this.speed = speed;
		else
			reducer = (Math.pow(xSpeed,2) + Math.pow(ySpeed, 2)) / MaxSpeed;
			xSpeed /= reducer;
			ySpeed /= reducer;
			this.speed = speed;	
	}
	
	private final static int MaxSpeed = 300000;
	
	public double getOrientation(){
		return this.orientation;
	}
	
	public boolean isValidOrientation(double orientation){
		return ((orientation >=0) && (orientation < 2*Math.PI));
	}
	
	public void setOrientation(double orientation) throws IllegalArgumentException{
		assert(isValidOrientation(orientation));
		this.orientation = orientation;
	}
	
	public void turn(double changeInOrientation){
		assert(isValidOrientation(this.orientation));
		assert(isValidOrientation(changeInOrientation));
		newTemporaryOrientation = (this.orientation + changeInOrientation);
		if (newTemporaryOrientation < 0) 
			this.orientation = newTemporaryOrientation + 2*Math.PI;
		if (newTemporaryOrientation > 2*Math.PI)
			this.orientation = newTemporaryOrientation - 2*Math.PI;
		else
			this.orientation = newTemporaryOrientation;
	}
	
	private double newTemporaryOrientation;
	
	public double getRadius(){
		return this.radius;
	}
	
	public void setRadius(double radius) throws IllegalArgumentException{
		if ((radius < 10000) || (radius > Double.POSITIVE_INFINITY)) 
			throw new IllegalArgumentException();
		this.radius = radius;
	}
	
	public boolean isValidShip(Ship ship) throws IllegalArgumentException{
		if (((ship.xPosition) < Double.NEGATIVE_INFINITY) || ((ship.xPosition) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.yPosition) < Double.NEGATIVE_INFINITY) || ((ship.yPosition) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.radius) < 10000) || ((ship.radius) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.orientation) < 0) || ((ship.orientation) > 2*Math.PI))
			throw new IllegalArgumentException();
		else
			return true;
	}
	
	public double getDistanceBetween(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		return Math.sqrt(Math.pow(ship1.xPosition - ship2.xPosition, 2) + Math.pow(ship1.yPosition - ship2.yPosition, 2)) - ship1.radius - ship2.radius; 
	}
	
	public boolean overlap(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		if (ship1 == ship2)
			return true;
		else 
			if (getDistanceBetween(ship1, ship2) < 0)
				return true;
			else 
				return false;
	}
	
	public double getTimeToCollision(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		if (((ship2.xSpeed-ship1.xSpeed)*(ship2.xPosition-ship1.xPosition)+(ship2.ySpeed-ship1.ySpeed)*(ship2.yPosition-ship1.yPosition)) > 0)
			return Double.POSITIVE_INFINITY;
		if ((Math.pow((ship2.xSpeed-ship1.xSpeed)*(ship2.xPosition-ship1.xPosition)+(ship2.ySpeed-ship1.ySpeed)*(ship2.yPosition-ship1.yPosition),2) - 
				(Math.pow(ship2.xSpeed-ship1.xSpeed, 2)+Math.pow(ship2.ySpeed-ship1.ySpeed, 2))*(Math.pow((ship2.xPosition-ship1.xPosition),2)+Math.pow((ship2.yPosition-ship1.yPosition), 2)) - 
				Math.pow(ship1.xPosition-ship2.xPosition, 2) - Math.pow(ship1.yPosition-ship2.yPosition, 2)) < 0)
			return Double.POSITIVE_INFINITY;
		else
			return ((-((ship2.xSpeed-ship1.xSpeed)*(ship2.xPosition-ship1.xPosition)+(ship2.ySpeed-ship1.ySpeed)*(ship2.yPosition-ship1.yPosition)) - 
					Math.sqrt((Math.pow((ship2.xSpeed-ship1.xSpeed)*(ship2.xPosition-ship1.xPosition)+(ship2.ySpeed-ship1.ySpeed)*(ship2.yPosition-ship1.yPosition),2) - 
				(Math.pow(ship2.xSpeed-ship1.xSpeed, 2)+Math.pow(ship2.ySpeed-ship1.ySpeed, 2))*(Math.pow((ship2.xPosition-ship1.xPosition),2)+Math.pow((ship2.yPosition-ship1.yPosition), 2)) - 
				Math.pow(ship1.xPosition-ship2.xPosition, 2) - Math.pow(ship1.yPosition-ship2.yPosition, 2)))) / 
					((Math.pow(ship2.xSpeed-ship1.xSpeed, 2)) + (Math.pow(ship2.ySpeed-ship1.ySpeed, 2))));
	}
	
	public boolean isValidDuration(double duration){
		return duration >= 0;
	}
	
	
	public void move(double duration) throws IllegalArgumentException{
		assert (isValidDuration(duration));
		double[] newposition = {this.getPosition()[0] + this.getSpeed()[0]*duration, this.getPosition()[1] + this.getSpeed()[1]*duration};
		setPosition(newposition);
	}
	
	public void thrust(double a) {
		if (a < 0)
			a = 0;
		double[] newspeed = {this.getSpeed()[0] + a*Math.cos(this.getOrientation()) , this.getSpeed()[1] + a*Math.sin(this.getOrientation())};
		setSpeed(newspeed);
	}
	
}


