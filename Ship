package asteroids.model;

public class Ship {
	
	/**Create a ship with a given position (x,y), given speed (vx,vy), 
	 * given orientation and given radius. 
	 * @param xPosition
	 * 			The x-coordinate of the position of the new ship.
	 * @param yPosition
	 * 			The y-coordinate of the position of the new ship.			
	 * @param xSpeed
	 * 			The x-coordinate of the speed of the new ship.
	 * @param ySpeed
	 * 			The y-coordinate of the speed of the new ship.
	 * @param orientation
	 * 			The direction that the new ship is facing expressed as an angle in radians.
	 * @param radius
	 * 			The radius of the new ship.
	 * @post  The given position is set as the new position of the new ship.
	 * @post  The given speed is set as the new speed of the new ship.
	 * @post  The given orientation is set as the new orientation of the new ship.
	 * @post  The given radius is set as the new radius of the new ship.			
	 * @throws IllegalArgumentException
	 */
	public Ship(double xPosition, double yPosition, double xSpeed, double ySpeed, 
			double orientation, double radius) throws IllegalArgumentException {
		this.setPosition(new double[] {xPosition,yPosition});
		this.setSpeed(new double[] {xSpeed,ySpeed});
		this.setOrientation(orientation);
		this.setRadius(radius);
	}
	
	private double xPosition;
	private double yPosition;
	private double xSpeed;
	private double ySpeed;
	private double orientation;
	private double radius;
	
	/**
	 * It returns an array of length 2, at index 0 you find the x-coordinate 
	 * and at index 1 you find the y-coordinate.
	 * @return The position of the ship.
	 */
	public double[] getPosition(){
		return this.position;
	}
	
	/**
	 * Set the position of the ship to the given position.
	 * @param position
	 * 			x- and y-coordinate of the position.
	 * @post The given position is set as the new position of the new ship.
	 * @throws IllegalArgumentException
	 * 			The given position isn't valid if the coordinates of 
	 * 			the position aren't greater than Positive infinity and smaller than negative infinity.
	 * 			If the position is NaN. 
	 * 			The given position isn't valid if position isn't an array of length 2.
	 */
	private void setPosition(double[] position) throws IllegalArgumentException{
		if ((xPosition < Double.NEGATIVE_INFINITY) || (xPosition > Double.POSITIVE_INFINITY) 
				|| (yPosition < Double.NEGATIVE_INFINITY) || (yPosition > Double.POSITIVE_INFINITY)
				|| (xPosition == Double.NaN) || (yPosition == Double.NaN)) 
			throw new IllegalArgumentException();
		if (position.length != 2) throw new IllegalArgumentException();
		this.position = position;
	}
	
	private double[] position = new double[2];
	
	private double[] speed = new double[2];
	
	/**
	 * It returns an array of length 2, at index 0 you find the speed of the x-coordinate
	 * and at index 1 you find the speed of the y-coordinate.
	 * @return The speed of the ship.
	 */
	public double[] getSpeed(){
		return this.speed;
	}
	
	private double reducer;
	
	/**
	 * @param speed
	 * 			The speed of the x-coordinate and the speed of the y-coordinate of the ship.
	 * @post If the speed of the x-coordinate is NaN, it turns into zero.
	 * @post If the speed of the y-coordinate is NaN, it turns into zero.
	 * @post If the given speed is equal or smaller then the speed of light, 
	 * the speed of the ship will be the given speed of the ship.
	 * @post If the given speed is faster than the speed of light, the new speed will be in the same direction as the
	 * given speed, but the speed will be the speed of light.
	 */
	public void setSpeed (double[] speed) {
		if (xSpeed == Double.NaN)
			xSpeed=0;
		if (ySpeed == Double.NaN)
			ySpeed=0;
		if (Math.sqrt(Math.pow( xSpeed , 2) + Math.pow(ySpeed, 2) ) <= MaxSpeed)
			this.speed = speed;
		else
			reducer = (Math.pow(xSpeed,2) + Math.pow(ySpeed, 2)) / MaxSpeed;
			xSpeed /= reducer;
			ySpeed /= reducer;
			this.speed = speed;	
	}
	
	private final static int MaxSpeed = 300000;
	
	/**
	 * It returns the direction that the new ship is facing expressed as an angle in radians.
	 * @return The orientation of the ship.
	 */
	public double getOrientation(){
		return this.orientation;
	}
	
	/**
	 * It returns if the given orientation is a valid orientation as a boolean type. 
	 * @param orientation
	 * 			An possible orientation for the ship.
	 * @return	Returns the validity of an orientation for the ship.
	 */
	public boolean isValidOrientation(double orientation){
		return ((orientation >=0) && (orientation < 2*Math.PI));
	}
	
	/**
	 * Set the orientation of the ship to the given orientation.
	 * @param orientation
	 * 			The orientation of the ship.
	 * @pre The orientation is valid.
	 * @throws IllegalArgumentException
	 * 			The given orientation isn't valid.
	 */
	public void setOrientation(double orientation) throws IllegalArgumentException{
		assert(isValidOrientation(orientation));
		this.orientation = orientation;
	} 
	
	/**
	 * 
	 * @param changeInOrientation
	 * 			The angle of the difference in orientation between the position before change and after change.
	 * @pre The current orientation is valid.
	 * @pre The changeInOrientation is valid.
	 * @post If the temporary orientation is smaller than zero, the new orientation is equal to 2 PI added to the 
	 * temporary orientation.
	 * @post If the temporary orientation is greater than 2*PI, the new orientation is equal to the difference between
	 * the temporary orientation and 2*PI. 
	 */
	public void turn(double changeInOrientation){
		assert(isValidOrientation(this.orientation));
		assert(isValidOrientation(changeInOrientation));
		newTemporaryOrientation = (this.orientation + changeInOrientation);
		if (newTemporaryOrientation < 0) 
			this.orientation = newTemporaryOrientation + 2*Math.PI;
		if (newTemporaryOrientation > 2*Math.PI)
			this.orientation = newTemporaryOrientation - 2*Math.PI;
		else
			this.orientation = newTemporaryOrientation;
	}
	
	private double newTemporaryOrientation;
	
	/**
	 * It returns the orientation the radius of the ship.
	 * @return the radius of the ship.
	 */
	public double getRadius(){
		return this.radius;
	}
	
	/**
	 * Sets the radius of the ship to the given radius.
	 * @param radius
	 * 			The radius of the ship.
	 * @throws IllegalArgumentException
	 * 			It isn't an valid radius as radius is smaller as ten and the radius isn't greater than positive infinity.
	 */
	public void setRadius(double radius) throws IllegalArgumentException{
		if ((radius < 10) || (radius > Double.POSITIVE_INFINITY)) 
			throw new IllegalArgumentException();
		this.radius = radius;
	}
	
	/**
	 * It returns a boolean type. It returns true if the ship is a valid ship.
	 * @param ship
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @return An boolean value true
	 * @throws IllegalArgumentException
	 * 			It isn't a valid ship.
	 */
	public boolean isValidShip(Ship ship) throws IllegalArgumentException{
		if (((ship.xPosition) < Double.NEGATIVE_INFINITY) || ((ship.xPosition) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.yPosition) < Double.NEGATIVE_INFINITY) || ((ship.yPosition) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.radius) < 10000) || ((ship.radius) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((ship.orientation) < 0) || ((ship.orientation) > 2*Math.PI))
			throw new IllegalArgumentException();
		else
			return true;
	}
	
	/**
	 * It returns the distance between two given ships.
	 * @param ship1
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @param ship2
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @return The distance between ship1 and ship2.
	 * @throws IllegalArgumentException
	 * 			If ship1 or/and ship2 aren't valid.
	 */
	public double getDistanceBetween(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		return Math.sqrt(Math.pow(ship1.xPosition - ship2.xPosition, 2) + Math.pow(ship1.yPosition - ship2.yPosition, 2)) - ship1.radius - ship2.radius; 
	}
	
	/**
	 * Returns a boolean type. Returns if the two given ships are at the same spot.
	 * @param ship1
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @param ship2
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @return If ship1 and ship2 are at the same spot.
	 * @throws IllegalArgumentException
	 * 			If ship1 or/and ship2 aren't valid.
	 */
	public boolean overlap(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		if (ship1 == ship2)
			return true;
		else 
			if (getDistanceBetween(ship1, ship2) < 0)
				return true;
			else 
				return false;
	}
	
	/**
	 * When the ships collide the distance between the centres is equal to the sum of both radiuses
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The sum of both radiuses
	 */
	
	private double distanceBetweenCentersAtCollision(Ship ship1, Ship ship2){
		return ship1.getRadius() + ship2.getRadius();
	}
	
	/**
	 * The difference between the x-coordinates of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both x-coordinates
	 */
	
	private double deltaX(Ship ship1, Ship ship2){
		return ship1.xPosition - ship2.xPosition;
	}
	
	/**
	 * The difference between the y-coordinates of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both y-coordinates
	 */
	
	private double deltaY(Ship ship1, Ship ship2){
		return ship1.yPosition - ship2.yPosition;
	}
	
	/**
	 * The difference between the x-coordinates and y-coordinates of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both x-coordinates and y-coordinates
	 */
	
	private double[] deltaPosition(Ship ship1, Ship ship2){
		return new double[]{ship1.deltaX(ship1, ship2),ship1.deltaY(ship1, ship2)};
	}
	
	/**
	 * The difference between the speed in x-direction of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both speeds in x-direction
	 */
	
	private double deltaVX(Ship ship1, Ship ship2){
		return ship1.xSpeed - ship2.xSpeed;
	}
	
	/**
	 * The difference between the speed in y-direction of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both speeds in y-direction
	 */
	
	private double deltaVY(Ship ship1, Ship ship2){
		return ship1.ySpeed - ship2.ySpeed;
	}
	
	/**
	 * The difference between the speed in x-direction and y-direction of both ships
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The difference between both speeds in x-direction and y-direction
	 */
	
	private double[] deltaSpeed(Ship ship1, Ship ship2){
		return new double[]{ship1.deltaVX(ship1, ship2),ship1.deltaVY(ship1, ship2)};
	}
	
	/**
	 * This function gives a double which is the sum of the product of the first number from the first vector and the 
	 * first number from the second vector and the product of the second number of the first vector and the second number of the second vector
	 * @param vector1
	 * 		The first vector of length 2
	 * @param vector2
	 * 		The second vector of length 2
	 * @return
	 * 		the dot product of 2 vectors of length 2 (result is a single value)
	 */
	
	private static double dotProduct(double[] vector1, double[] vector2) {
		return ((vector1[0] * vector2[0]) + (vector1[1] * vector2[1]));
	}
	
	/**
	 * This function registers a certain value that is used in the collision function, if it is negative,
	 * the ships will never collide, if it is positive they will collide
	 * @param ship1
	 * 		First ship
	 * @param ship2
	 * 		Second ship
	 * @return
	 * 		The value d
	 */
	
	private double d(Ship ship1, Ship ship2){
		return Math.pow(dotProduct(ship1.deltaSpeed(ship1, ship2),ship1.deltaPosition(ship1, ship2)), 2) - 
				(dotProduct(ship1.deltaSpeed(ship1, ship2),ship1.deltaSpeed(ship1, ship2))) * (dotProduct(ship1.deltaPosition(ship1, ship2),ship1.deltaPosition(ship1, ship2))
				- Math.pow(ship1.distanceBetweenCentersAtCollision(ship1, ship2), 2));
	}
	
	/**
	 * This method will give at what time in the future 2 ships would collide if they were to continue forward without changing direction
	 * or accelerating/slow down
	 * @param ship1
	 * 		The first ship of the 2 ships we are comparing
	 * @param ship2
	 * 		The second ship of the 2 ships we are comparing
	 * @return
	 * 		If the ships never collide this function will return positive infinity (Double.POSITIVE_INFINITY)
	 * 		If they would collapse the function will return a duration described as a double
	 * @throws IllegalArgumentException
	 * 		If one or both of the ships are not valid ships then the function will give an error
	 */
	
	public double getTimeToCollision(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		if ((dotProduct(ship1.deltaSpeed(ship1, ship2),ship1.deltaPosition(ship1, ship2))) > 0)
			return Double.POSITIVE_INFINITY;
		if ((ship1.d(ship1, ship2)) < 0)
			return Double.POSITIVE_INFINITY;
		else
			return (-(dotProduct(ship1.deltaSpeed(ship1, ship2),ship1.deltaPosition(ship1, ship2)) + Math.sqrt(ship1.d(ship1, ship2)))
					/ dotProduct(ship1.deltaSpeed(ship1, ship2),ship1.deltaSpeed(ship1, ship2)));
	}
	
	/**
	 * This function will return the centre of the first ship at the time of collision
	 * @param ship1
	 * 		The first ship
	 * @param ship2
	 * 		The second ship
	 * @return
	 * 		The position of the centre of the first ship
	 * @throws IllegalArgumentException
	 * 		If the ships are not valid ships or if they already overlap the function will give an error
	 */
	
	public double[] getCollisionPosition(Ship ship1, Ship ship2) throws IllegalArgumentException{
		if (isValidShip(ship1) == false)
			throw new IllegalArgumentException();
		if (isValidShip(ship2) == false)
			throw new IllegalArgumentException();
		if (ship1.overlap(ship1, ship2))
			throw new IllegalArgumentException();
		if (getTimeToCollision(ship1, ship2) == Double.POSITIVE_INFINITY)
			return null;
		else
			return new double[] {ship1.xPosition + ship1.xSpeed*getTimeToCollision(ship1, ship2),ship1.yPosition + ship1.ySpeed*getTimeToCollision(ship1, ship2)};
	}
	
	/**
	 * Returns a boolean type. 
	 * @param duration
	 * 			The given duration.
	 * @return It return if the duration is valid.
	 */
	public boolean isValidDuration(double duration){
		return duration >= 0;
	}
	
	/**
	 * Sets the new position after a certain duration.
	 * @param duration
	 * 			The given duration.
	 * @throws IllegalArgumentException
	 * 			If the duration isn't valid.
	 */
	public void move(double duration) throws IllegalArgumentException{
		assert (isValidDuration(duration));
		double[] newposition = {this.getPosition()[0] + this.getSpeed()[0]*duration, this.getPosition()[1] + this.getSpeed()[1]*duration};
		setPosition(newposition);
	}
	
	/**
	 * It changes the speed of the ship but the orientation remains the same.
	 * @param a
	 * 		The given amount that changes the speed.
	 * @post if the given amount a is smaller than 0, the given amount a will become zero.
	 * 
	 */
	public void thrust(double a) {
		if (a < 0)
			a = 0;
		double[] newspeed = {this.getSpeed()[0] + a*Math.cos(this.getOrientation()) , this.getSpeed()[1] + a*Math.sin(this.getOrientation())};
		setSpeed(newspeed);
	}
	
}



