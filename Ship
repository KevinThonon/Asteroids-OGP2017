/**
 * Class ship for the first part of the project of ogp 2017
 * 
 * @author Kevin Thonon & Jef Jonkers
 */

package asteroids.model;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import be.kuleuven.cs.som.annotate.Basic;
import be.kuleuven.cs.som.annotate.Immutable;
import be.kuleuven.cs.som.annotate.Raw;

public class Ship extends Entity{
	
	/**Create a ship with a given position (x,y), given speed (vx,vy), 
	 * given orientation and given radius. 
	 * @param xPosition
	 * 			The x-coordinate of the position of the new ship.
	 * @param yPosition
	 * 			The y-coordinate of the position of the new ship.			
	 * @param xSpeed
	 * 			The x-coordinate of the speed of the new ship.
	 * @param ySpeed
	 * 			The y-coordinate of the speed of the new ship.
	 * @param orientation
	 * 			The direction that the new ship is facing expressed as an angle in radians.
	 * @param radius
	 * 			The radius of the new ship.
	 * @post  The given position is set as the new position of the new ship.
	 * @post  The given speed is set as the new speed of the new ship.
	 * @post  The given orientation is set as the new orientation of the new ship.
	 * @post  The given radius is set as the new radius of the new ship.			
	 * @throws IllegalArgumentException if any value is invalid.
	 */
	@Raw
	public Ship(double xPosition, double yPosition, double xSpeed, double ySpeed, 
			double orientation, double radius,double mass) throws IllegalArgumentException {
		super(xPosition,yPosition,xSpeed,ySpeed);
		this.setRadius(radius);
		this.setOrientation(orientation);
		this.setMass(mass);
		this.setDensity(density);
	}
	
	
	private double radius;
	private double orientation;
	private double mass;
	private double density;
	
	/**
	 * It returns the radius of the ship.
	 * @return the radius of the ship.
	 */
	@Immutable
	public double getRadius(){
		return this.radius;
	}
	
	/**
	 * Sets the radius of the ship to the given radius.
	 * @param radius
	 * 			The radius of the ship.
	 * @throws IllegalArgumentException
	 * 			Throws an error if provided radius is smaller than ten or greater than positive infinity.
	 */
	@Immutable
	protected void setRadius(double radius) throws IllegalArgumentException{
		if ((radius < 10) || (radius > Double.POSITIVE_INFINITY)) 
			throw new IllegalArgumentException();
		this.radius = radius;
	}
	
	/**
	 * It returns the direction that the new ship is facing expressed as an angle in radians.
	 * @return The orientation of the ship.
	 */
	public double getOrientation(){
		return this.orientation;
	}
	
	/**
	 * It returns if the given orientation is a valid orientation as a boolean type. 
	 * @param orientation
	 * 			An possible orientation for the ship.
	 * @return	Returns the validity of an orientation for the ship.
	 *			|((orientation >=0) && (orientation < 2*Math.PI) && !(orientation == Double.NaN))
	 */
	public static boolean isValidOrientation(double orientation){
		return ((orientation >=0) && (orientation < 2*Math.PI) && !(orientation == Double.NaN));
	}
	
	/**
	 * Set the orientation of the ship to the given orientation.
	 * @param orientation
	 * 			The orientation of the ship.
	 * @pre The orientation is valid.
	 * 		isValidOrientation = true
	 * @throws IllegalArgumentException
	 * 			The given orientation isn't valid.
	 */
	@Basic
	public void setOrientation(double orientation) throws IllegalArgumentException{
		assert(isValidOrientation(orientation));
		this.orientation = orientation;
	} 
	
	/**
	 * Set the new orientation of a ship, in other words, turn the ship.
	 * @param changeInOrientation
	 * 			The angle of the difference in orientation between the position before change and after change.
	 * @pre The current orientation is valid.
	 * @pre The changeInOrientation is valid.
	 * @post If the temporary orientation is smaller than zero, the new orientation is equal to 2 PI added to the 
	 * temporary orientation.
	 * @post If the temporary orientation is greater than 2*PI, the new orientation is equal to the difference between
	 * the temporary orientation and 2*PI. 
	 */
	public void turn(double changeInOrientation){
		assert(isValidOrientation(this.orientation));
		assert( Math.abs(changeInOrientation) < 2*Math.PI);
		newTemporaryOrientation = (this.orientation + changeInOrientation);
		if (newTemporaryOrientation < 0)
			this.setOrientation(newTemporaryOrientation + 2*Math.PI);
		else if (newTemporaryOrientation > 2*Math.PI)
			this.setOrientation(newTemporaryOrientation - 2*Math.PI);
		else
			this.orientation = newTemporaryOrientation;
	}
	
	private double newTemporaryOrientation;
	
	/**
	 * The minimal density of a ship
	 */
	private final static double minimalDensity = 1.42 * Math.pow(10, 12);
	
	/**
	 * Get the density of a ship
	 * @return The density of this ship
	 */
	public double getDensity(){
		return this.density;
	}
	
	/**
	 * Set the density of this ship
	 * @param density
	 * 		If the provided density is smaller than the minimal density, set the density of this ship to the minimal density
	 * 		Otherwise the provided density will be the ships density
	 */
	@Immutable @Basic
	private void setDensity(double density){
		if (density < minimalDensity)
			this.density = minimalDensity;
		else
			this.density = density;
	}
	
	/**
	 * Calculate the total mass of all the bullets currently belonging to this ship
	 * @return The total mass of all this ship's bullets
	 * 		|double totalMass = 0;
			|for (Bullet bullet : this.getBullets())
			|	totalMass += bullet.getMass();
	 */
	public double totalBulletsMass(){
		double totalMass = 0;
		for (Bullet bullet : this.getBullets())
			totalMass += bullet.getMass();
		return totalMass;
	}
	
	/**
	 * Get the total mass of this ship + its bullets
	 * @return Total mass
	 * 		|(this.mass + this.totalBulletsMass())
	 */
	public double getMass(){
		return (this.mass + this.totalBulletsMass());
	}
	
	/**
	 * Set the mass of this ship, if the provided mass is smaller than the minimal mass, set the minimal mass as the ship mass
	 * @param mass
	 * 		The mass of the ship
	 */
	@Basic
	private void setMass(double mass){
		double minimalMass = 4/3 * Math.PI * Math.pow(this.getRadius(),3)* minimalDensity;
		if (mass < minimalMass)
			this.mass = minimalMass;
		else 
			this.mass = mass;
	}
	
	/**
	 * Get all the bullets of this ship
	 * @return
	 * 		A set with all the bullets of this ship
	 */
	public Set<Bullet> getBullets() {
		return this.bullets;
	}

	public Set<Bullet> bullets = new HashSet<Bullet>();
	
	/**
	 * Check whether the provided bullet is a valid bullet 
	 * @param bullet
	 * 		The bullet that is to be checked
	 * @return A boolean stating if the bullet is valid or not
	 * 		|if (bullet == null)
	 *		|	return false;
	 *		|if (bullet.getShip() != null && bullet.getShip() != this)
	 *		|	return false;
	 *		|if (bullet.getSource() != null && bullet.getSource() != this)
	 *		|	return false;
	 *		|else
	 *		|	return true;
	 */
	public boolean isValidBullet(Bullet bullet){
		if (bullet == null)
			return false;
		if (bullet.getShip() != null && bullet.getShip() != this)
			return false;
		if (bullet.getSource() != null && bullet.getSource() != this)
			return false;
		else
			return true;
	}
	
	/**
	 * Add a single bullet to the ship
	 * @param bullet
	 * 		bullet to add
	 * @throws IllegalArgumentException
	 * 		If the provided bullet isn't valid throw an error
	 */
	public void addBullet(Bullet bullet){
		if (!(isValidBullet(bullet))) throw new IllegalArgumentException("Isn't a valid bullet");
		bullet.setShip(this);
		bullet.setPosition(this.getPosition());
		bullet.setWorld(this.getWorld());
		this.bullets.add(bullet);
	}
	
	/**
	 * Add a set of bullets to the ship
	 * @param bullets2
	 * 		The set of bullets to add
	 * @throws IllegalArgumentException
	 * 		If one of the provided bullets isn't valid throw an error
	 */
	public void addBullets(Collection<Bullet>bullets2){
		for (Bullet bullet : bullets2) this.addBullet(bullet);
	}
	
	/**
	 * Remove a bullet from this ship or this ships world
	 * @param bullet
	 * 		The bullet to remove
	 * @throws IllegalArgumentException
	 * 		If the provided bullet isn't valid throw an error
	 */
	public void removeBullet(Bullet bullet){
		if (bullet.getShip() != this) throw new IllegalArgumentException("Not a bullet of this ship.");
		else
			bullet.getWorld().removeEntity(bullet);
	}
	
	/**
	 * Remove a set of bullets from this ship or this ships world
	 * @param bullets
	 * 		The set of bullets to remove
	 * @throws IllegalArgumentException
	 * 		If one of the bullets isn't valid throw an error
	 */
	public void removeBullets(Bullet... bullets){
		for (Bullet bullet : bullets) bullet.getWorld().removeEntity(bullet);
	}
	
	/**
	 * Get the number of bullets of this ship
	 * @return
	 * 		The number of bullets
	 */
	public int getNumberOfBullets(){
		return this.bullets.size();
	}
	
	
	/**
	 * Fire one of the ships bullets.
	 * @post If the ship doesn't have any bullets left or is positioned in the world null, do nothing
	 * 		 If the bullet that is to be fired is partially out of bounds, destroy it.
	 * 			|if ((firedBullet.getPosition()[0] + firedBullet.getRadius() > this.getWorld().width) ||
	 *			|	(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0) ||
	 *			|	(firedBullet.getPosition()[1] + firedBullet.getRadius() > this.getWorld().height) ||
	 *			|	(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0))
	 *			|	removeBullet(firedBullet);
	 *		 If the bullet is totally in the world when it is fired from the ship, give it the same orientation as
	 *		 the ship but give is speed that is 250 faster than the ships current speed. Also remove this bullet from
	 *		 the ships bullets.
	 *		  	|firedBullet.setSpeed(new double[] {bulletXSpeed,bulletYSpeed});
	 *			|firedBullet.setSource(this);
	 *			|this.removeBullet(firedBullet); 
	 */
	public void fireBullet(){
		if (this.getWorld() == null)
			return;
		if (this.getNumberOfBullets() == 0)
			return;
		Bullet firedBullet = this.getBullets().iterator().next();
		double bulletXPosition = this.getPosition()[0] + (this.getRadius()+firedBullet.getRadius()) * Math.cos(this.getOrientation());
		double bulletYPosition = this.getPosition()[1] + (this.getRadius()+firedBullet.getRadius()) * Math.sin(this.getOrientation());
		double bulletXSpeed = 250 * Math.cos(this.getOrientation()) + this.getSpeed()[0];
		double bulletYSpeed = 250 * Math.sin(this.getOrientation()) + this.getSpeed()[1];
		firedBullet.setPosition(new double[] {bulletXPosition,bulletYPosition});
		if ((firedBullet.getPosition()[0] + firedBullet.getRadius() > this.getWorld().width) ||
			(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0) ||
			(firedBullet.getPosition()[1] + firedBullet.getRadius() > this.getWorld().height) ||
			(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0)){
			removeBullet(firedBullet);
		}
		else{
			firedBullet.setSpeed(new double[] {bulletXSpeed,bulletYSpeed});
			firedBullet.setSource(this);
			removeBullet(firedBullet);
		}
	}
	
	/**
	 * It returns a boolean type. It returns true if the ship is a valid ship.
	 * @param ship
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @return An boolean value true
	 * @throws IllegalArgumentException
	 * 			It isn't a valid ship because either position, speed, orientation or radius is invalid.
	 */
	public boolean isValidShip() throws IllegalArgumentException{
		if (((this.getPosition()[0]) < Double.NEGATIVE_INFINITY) || ((this.getPosition()[0]) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.getPosition()[1]) < Double.NEGATIVE_INFINITY) || ((this.getPosition()[1]) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.getRadius()) < 10000) || ((this.getRadius()) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.orientation) < 0) || ((this.orientation) > 2*Math.PI))
			throw new IllegalArgumentException();
		else
			return true;
	}
	
	/**
	 * Returns a boolean type. 
	 * @param duration
	 * 			The given duration.
	 * @return It return if the duration is not NaN.
	 * @return It return if the duration is valid.
	 */
	public boolean isValidDuration(double duration){
		if (duration == Double.NaN)
			return false;
		return duration >= 0;
	}
	
	/**
	 * Sets the new position after a certain duration.
	 * @param duration
	 * 			The given duration.
	 * @throws IllegalArgumentException
	 * 			If the duration isn't valid.
	 * @post The ship moved to a new location based on its speed and acceleration
	 * 		|this.setPosition(new double[] {this.getPosition()[0] + this.getSpeed()[0]*duration + 
					this.getAcceleration()*Math.cos(this.getOrientation())/2*Math.pow(duration, 2),
					this.getPosition()[1] + this.getSpeed()[1]*duration + 
					this.getAcceleration()*Math.sin(this.getOrientation())/2*Math.pow(duration, 2)})
	 */
	// TO-DO check of documentatie nog wel klopt.
	public void move(double duration) throws IllegalArgumentException{
		if (!(isValidDuration(duration)))
			throw new IllegalArgumentException("Duration isn't valid.");
		if (!isThrusterActive()){
			this.setPosition(new double[] {(this.getPosition()[0]) + ((this.getSpeed()[0])*duration),
					(this.getPosition()[1]) + (this.getSpeed()[1])*duration});
		}
		else{
			this.setPosition(new double[] {(this.getPosition()[0]) + (this.getSpeed()[0])*duration + 
					(this.getAcceleration())*Math.cos(this.getOrientation())*0.5*Math.pow(duration, 2),
					(this.getPosition()[1]) + (this.getSpeed()[1])*duration + 
					(this.getAcceleration())*Math.sin(this.getOrientation())*0.5*Math.pow(duration, 2)});
		}	
	}
	
	private boolean thrusterActive = false;
	
	/**
	 * Check whether the thruster is active
	 * @return
	 * 		A boolean that tells if the thruster is on or not
	 */
	public boolean isThrusterActive(){
		return thrusterActive;
	}
	
	/**
	 * Set the thruster to on
	 */
	public void thrustOn(){
		thrusterActive = true;
		this.thrust(this.getAcceleration());
	}
	
	/**
	 * Set the thruster to off
	 */
	public void thrustOff(){
		thrusterActive = false;
		this.thrust(this.getAcceleration());
	}
	
	/**
	 * Get the acceleration of this ship
	 * @return
	 * 		|double force = 1.1*Math.pow(10, 21);
	 *		|double acceleration = force/this.getMass();
	 *		|return acceleration;
	 */
	public double getAcceleration() {
		if (!thrusterActive)
			return 0;
		double force = 1.1*Math.pow(10, 21);
		double acceleration = force/this.getMass();
		return acceleration;
	}
	
	/**
	 * It changes the speed of the ship but the orientation remains the same.
	 * @param at
	 * 		The given amount that changes the speed| at = duration*acceleration.
	 * @post if the given amount at is smaller than 0 or if amount at is NaN or infinite , the given amount a will become zero and we keep the same velocity.
	 * @effect The speed of this ship is adapted
	 */
	//TO DO add the acceleartion of the ship
	public void thrust(double at) {
		if (this.isThrusterActive()){
			if (at < 0 || !(Double.isFinite(at)))
				at = 0;
			double[] newspeed = {this.getSpeed()[0] + at*Math.cos(this.getOrientation()) , this.getSpeed()[1] + at*Math.sin(this.getOrientation())};
			this.setSpeed(newspeed);
		}
	}
	
}
