/**
 * Class ship for the first part of the project of ogp 2017
 * 
 * @author Kevin Thonon & Jef Jonkers
 */

package asteroids.model;

import java.util.HashSet;
import java.util.Set;

public class Ship extends Entity{
	
	/**Create a ship with a given position (x,y), given speed (vx,vy), 
	 * given orientation and given radius. 
	 * @param xPosition
	 * 			The x-coordinate of the position of the new ship.
	 * @param yPosition
	 * 			The y-coordinate of the position of the new ship.			
	 * @param xSpeed
	 * 			The x-coordinate of the speed of the new ship.
	 * @param ySpeed
	 * 			The y-coordinate of the speed of the new ship.
	 * @param orientation
	 * 			The direction that the new ship is facing expressed as an angle in radians.
	 * @param radius
	 * 			The radius of the new ship.
	 * @post  The given position is set as the new position of the new ship.
	 * @post  The given speed is set as the new speed of the new ship.
	 * @post  The given orientation is set as the new orientation of the new ship.
	 * @post  The given radius is set as the new radius of the new ship.			
	 * @throws IllegalArgumentException
	 */
	public Ship(double xPosition, double yPosition, double xSpeed, double ySpeed, 
			double orientation, double radius, double mass, double density) throws IllegalArgumentException {
		super(xPosition,yPosition,xSpeed,ySpeed);
		this.setRadius(radius);
		this.setOrientation(orientation);
		this.setMass(mass);
		this.setDensity(density);
	}
	
	//-Can mass and density be variables of the ship? If so, do we have to change it in the facade?
	//-Do we have to be able to remove a Ship or bullet from a world? (this isn't asked in the assignment)
	//-How can we know if an entity is a ship or a bullet (needed for the collisions)?
	//-In the task they say next to the ship, do they mean in front of, and what if the ship is going
	//faster than the initial speed of the bullet? Does the bullet have to go 250 faster than the speed of the ship?
	//-When a bullet belongs to a ship, do we have to see it on screen (then we would have to write functions about
	//the movement of the bullets. Or is it enough if the ship only stocks this bullet (then the part about the center
	//of the bullet is unnecessary in the assignment)
	
	private double radius;
	private double orientation;
	private double mass;
	private double density;
	
	/**
	 * It returns the radius of the ship.
	 * @return the radius of the ship.
	 */
	public double getRadius(){
		return radius;
	}
	
	/**
	 * Sets the radius of the ship to the given radius.
	 * @param radius
	 * 			The radius of the ship.
	 * @throws IllegalArgumentException
	 * 			It isn't an valid radius as radius is smaller as ten and the radius isn't greater than positive infinity.
	 */
	protected void setRadius(double radius) throws IllegalArgumentException{
		if ((radius < 10) || (radius > Double.POSITIVE_INFINITY)) 
			throw new IllegalArgumentException();
		this.radius = radius;
	}
	
	/**
	 * It returns the direction that the new ship is facing expressed as an angle in radians.
	 * @return The orientation of the ship.
	 */
	public double getOrientation(){
		return this.orientation;
	}
	
	/**
	 * It returns if the given orientation is a valid orientation as a boolean type. 
	 * @param orientation
	 * 			An possible orientation for the ship.
	 * @return	Returns the validity of an orientation for the ship.
	 * 
	 * NAN bijsteken
	 * return ((orientation >=0) && (orientation < 2*Math.PI)); bijplakken
	 */
	public static boolean isValidOrientation(double orientation){
		return ((orientation >=0) && (orientation < 2*Math.PI));
	}
	
	/**
	 * Set the orientation of the ship to the given orientation.
	 * @param orientation
	 * 			The orientation of the ship.
	 * @pre The orientation is valid.
	 * 		isValidOrientation = true
	 * @throws IllegalArgumentException
	 * 			The given orientation isn't valid.
	 */
	public void setOrientation(double orientation) throws IllegalArgumentException{
		assert(isValidOrientation(orientation));
		this.orientation = orientation;
	} 
	
	/**
	 * 
	 * @param changeInOrientation
	 * 			The angle of the difference in orientation between the position before change and after change.
	 * @pre The current orientation is valid.
	 * @pre The changeInOrientation is valid.
	 * @post If the temporary orientation is smaller than zero, the new orientation is equal to 2 PI added to the 
	 * temporary orientation.
	 * @post If the temporary orientation is greater than 2*PI, the new orientation is equal to the difference between
	 * the temporary orientation and 2*PI. 
	 */
	public void turn(double changeInOrientation){
		assert(isValidOrientation(this.orientation));
		assert(isValidOrientation(changeInOrientation));
		newTemporaryOrientation = (this.orientation + changeInOrientation);
		if (newTemporaryOrientation < 0) 
			this.orientation = newTemporaryOrientation + 2*Math.PI;
		if (newTemporaryOrientation > 2*Math.PI)
			this.orientation = newTemporaryOrientation - 2*Math.PI;
		else
			this.orientation = newTemporaryOrientation;
	}
	
	private double newTemporaryOrientation;
	
	private final static double minimalDensity = 1.42 * Math.pow(10, 12);
	
	public double getDensity(){
		return this.density;
	}
	
	private void setDensity(double density){
		if (density < minimalDensity)
			this.density = minimalDensity;
		else
			this.density = density;
	}
	
	public double totalBulletsMass(){
		double totalMass = 0;
		for (Bullet bullet : this.getBullets())
			totalMass += bullet.getMass();
		return totalMass;
	}
	
	public double getMass(){
		return (this.mass + this.totalBulletsMass());
	}
	
	private void setMass(double mass){
		double minimalMass = 4/3 * Math.PI * Math.pow(this.getRadius(),3)* minimalDensity;
		if (mass < minimalMass)
			this.mass = minimalMass;
		else 
			this.mass = mass;
	}
	
	public Set<Bullet> getBullets() {
		return this.bullets;
	}

	public Set<Bullet> bullets = new HashSet<Bullet>();

	public boolean isValidBullet(Bullet bullet){
		if (bullet == null)
			return false;
		if (bullet.getShip() != null && bullet.getShip() != this)
			return false;
		if (bullet.getSource() != null && bullet.getSource() != this)
			return false;
		else
			return true;
	}
	
	public void addBullet(Bullet bullet){
		if (!(isValidBullet(bullet))) throw new IllegalArgumentException();
		bullets.add(bullet);
		if (bullet.getWorld() != null)
			bullet.getWorld().removeBullet(bullet);
		else
			bullet.setShip(this);
			bullet.setPosition(this.getPosition());
	}
	
	public void addBullets(Bullet...bullets){
		for (Bullet bullet : bullets)
			if (!(isValidBullet(bullet))) throw new IllegalArgumentException();
			else
				this.addBullet(bullet);
	}
	
	public void removeBullet(Bullet bullet){
		if (bullet.getShip() != this) throw new IllegalArgumentException();
		else
			bullet.getWorld().removeBullet(bullet);
	}
	
	public void removeBullets(Bullet... bullets){
		for (Bullet bullet : bullets)
			if (bullet.getShip() != this) throw new IllegalArgumentException();
			else
				bullet.getWorld().removeBullet(bullet);
	}
	
	public int getNumberOfBullets(){
		return bullets.size();
	}
	
	public void fireBullet(){
		if (this.getWorld() == null)
			return;
		if (this.getNumberOfBullets() == 0)
			return;
		Bullet firedBullet = this.getBullets().iterator().next();
		double bulletXPosition = this.getPosition()[0] + (this.getRadius()+firedBullet.getRadius()) * Math.cos(this.getOrientation());
		double bulletYPosition = this.getPosition()[1] + (this.getRadius()+firedBullet.getRadius()) * Math.sin(this.getOrientation());
		double bulletXSpeed = 250 * Math.cos(this.getOrientation());
		double bulletYSpeed = 250 * Math.sin(this.getOrientation());
		firedBullet.setPosition(new double[] {bulletXPosition,bulletYPosition});
		if ((firedBullet.getPosition()[0] + firedBullet.getRadius() > this.getWorld().width) ||
				(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0) ||
				(firedBullet.getPosition()[1] + firedBullet.getRadius() > this.getWorld().height) ||
				(firedBullet.getPosition()[0] - firedBullet.getRadius() < 0))
			removeBullet(firedBullet);
		else
			firedBullet.setSpeed(new double[] {bulletXSpeed,bulletYSpeed});
			firedBullet.setSource(this);
			this.removeBullet(firedBullet);
	}
	
	/**
	 * It returns a boolean type. It returns true if the ship is a valid ship.
	 * @param ship
	 * 			A ship with a given position (x,y), given speed (vx,vy), given orientation and given radius.
	 * @return An boolean value true
	 * @throws IllegalArgumentException
	 * 			It isn't a valid ship.
	 */
	public boolean isValidShip() throws IllegalArgumentException{
		if (((this.getPosition()[0]) < Double.NEGATIVE_INFINITY) || ((this.getPosition()[0]) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.getPosition()[1]) < Double.NEGATIVE_INFINITY) || ((this.getPosition()[1]) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.getRadius()) < 10000) || ((this.getRadius()) > Double.POSITIVE_INFINITY))
			throw new IllegalArgumentException();
		if (((this.orientation) < 0) || ((this.orientation) > 2*Math.PI))
			throw new IllegalArgumentException();
		else
			return true;
	}
	
	/**
	 * Returns a boolean type. 
	 * @param duration
	 * 			The given duration.
	 * @return It return if the duration is valid.
	 */
	public boolean isValidDuration(double duration){
		return duration >= 0;
	}
	
	/**
	 * Sets the new position after a certain duration.
	 * @param duration
	 * 			The given duration.
	 * @throws IllegalArgumentException
	 * 			If the duration isn't valid.
	 * defensief programmeren
	 * @post toevoegen, wat is er gebeurd?
	 */
	public void move(double duration) throws IllegalArgumentException{
		assert (isValidDuration(duration));
		double[] newposition = {this.getPosition()[0] + this.getSpeed()[0]*duration, this.getPosition()[1] + this.getSpeed()[1]*duration};
		setPosition(newposition);
	}
	
	private boolean thrusterActive = false;
	
	private boolean isThrusterActive(){
		return thrusterActive;
	}
	
	private void thrustOn(){
		thrusterActive = true;
		this.thrust(this.getAcceleration());
	}
	
	private void thrustOff(){
		thrusterActive = false;
		this.thrust(this.getAcceleration());
	}
	
	
	public double getAcceleration() {
		if (!thrusterActive)
			return 0;
		double force = 1.1*Math.pow(10, 21);
		double acceleration = force/this.getMass();
		return acceleration;
	}
	
	/**
	 * It changes the speed of the ship but the orientation remains the same.
	 * @param a
	 * 		The given amount that changes the speed.
	 * @post if the given amount a is smaller than 0, the given amount a will become zero and we keep the same velocity.
	 * @effect verwijst naar setSpeed
	 * 
	 */
	public void thrust(double a) {
		if (this.isThrusterActive())
			if (a < 0)
				a = 0;
			double[] newspeed = {this.getSpeed()[0] + a*Math.cos(this.getOrientation()) , this.getSpeed()[1] + a*Math.sin(this.getOrientation())};
			setSpeed(newspeed);
	}
	
}
